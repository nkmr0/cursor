# Cursor 活用法

---

## 1. イントロダクション (5 分)

---

### 本日のゴールとアジェンダ

-   **現状認識**: 基本的なCursorの操作はできている前提で進める
-   **ゴール**: Cursorの仕組みを理解し、開発プロセスの中に積極的に活用できるようになる。

---

### コア機能の利用率

Cursorの利用状況は以下のページで確認できる：

- 設定ページ: https://www.cursor.com/ja/settings
- 分析ページ: https://www.cursor.com/ja/analytics

---

## 2. Cursor コア機能の再確認 (10 分)

---

### Tab: 文脈に応じた自動補完

-   **文脈に応じた複数行生成**: 周囲のコードパターンやコメントを読み取り、自然で適切な複数行コード（関数本体、クラス定義など）を提案。
-   **スタイル学習**: プロジェクト内の既存コードからコーディングスタイル（インデント、命名規則など）を学習し、一貫性を保持。
-   **軽微なエラー修正**: タイプミスや閉じ括弧忘れなど、簡単な構文エラーを補完時に自動修正することがある。

---

### Cmd/Ctrl+K (インライン): ピンポイント AI 修正

-   **選択範囲への精密指示**: コードの一部を選択し、具体的な指示を与えることで、その範囲に限定した AI 操作が可能。
-   **例**: 「この関数をリファクタリングして、可読性を向上させて」「このクラスにドキュメントコメントを追加して」「この処理に対応するユニットテストを生成して」「このシェルコマンドを生成して」
-   **Tips**: 小〜中規模のコード修正、特定部分のコード生成、ドキュメント/テスト生成に最適。指示が具体的であるほど、期待に近い結果が得られる。

---

### Cmd/Ctrl+L (チャット/エージェント): コードベース対話ハブ

-   **Ask モード**: コードベース全体や特定ファイルについて質問、解説要求、関連ドキュメント検索などに使用。「この関数の役割は？」「このエラーの原因は？」
-   **Agent モード**: さらに複雑で自律的なタスクを実行。複数ファイルにまたがる変更、ターミナルコマンドの実行（ビルド、テストなど）、エラー発生時の自動修正試行ループなどが可能。

---

## 3. コンテキストの重要性 (15 分)

---

### コンテキストの重要性：なぜ質が重要か？

-   **AI の回答精度はコンテキストの質に依存**: LLM は与えられた情報（コンテキスト）のみを基に回答を生成。コンテキストが不十分だったり、不正確だったりすると、AI は推測で補うか、見当違いの回答しかできない。
-   **適切な情報伝達で AI の能力を最大化**: 関連性の高いファイルを正確に指定したり、背景情報を伝えたりすることで、AI は人間が意図するタスクをより深く理解し、高精度な支援を提供できる。ゴミを入れればゴミが出てくる（Garbage In, Garbage Out）原則。

---

**コードインデックスとコンテキスト意識**

**ローカルでのインデックス作成:** Cursor はプロジェクトを開くと、コードベースの構造（ファイル、関数、クラスなど）をローカル環境で解析し、インデックスを作成。これにより、@シンボルでの参照やコードベース全体に関する質問が可能に。

[https://docs.cursor.com/context/codebase-indexing](https://docs.cursor.com/context/codebase-indexing)

**Tips:** コードベースの中で読み込みが不要なものを指定することでパフォーマンスが上がることもあります。

[https://docs.cursor.com/context/ignore-files](https://docs.cursor.com/context/ignore-files)

**AI が見ているものを意識する:** チャットや編集を依頼する際、AI が現在どのファイルやコード片を「見ている」状態なのか（＝コンテキストに含まれているか）を意識することが極めて重要。

-   **明示的な指定:** 
    - `@` で明示的に指定されたファイルやリンク
    - User Rules
    - .cursorrules
    - Project Rules
-   **暗黙的な指定:**
    - 現在アクティブなエディタタブ
    - 開いているファイルのLinter Error
    - Agentモードでの読み込みファイル

**確認の重要性:** 期待通りの応答が得られない場合、AI が必要な情報（ファイル、関数定義、関連コードなど）をコンテキストとして受け取れていない可能性あり。「今どのファイルを参照していますか？」のように AI に確認したり、明示的に `@` で追加したりする意識を持つこと。

### @シンボルエコシステム解説：AI のコンテキストを指定する

-   **`@files&folder`**: 特定のファイルやフォルダを AI の参照対象に追加。複数指定可。
-   **`@web`**: 指定した URL の Web ページ内容を取得し、参照対象に追加。技術ブログやドキュメント参照に。
-   **`@Docs`**: 事前に登録したチーム固有ドキュメント（後述）を参照対象に追加。
-   **`@git`**: Git の情報を参照。コミット履歴 (`@git log`) や差分 (`@git diff`) をコンテキストに追加し、変更内容に関する質問などに活用。
-   **`@terminal`**: ターミナルの情報をすべて送ることができるためテスト結果やアプリケーションログの共有が楽
-   **Tips**: 質問や指示を行う際に、どの情報源を AI に見せるべきか意識し、正確に `@` シンボル を使い分けること。複数の `@` シンボル を組み合わせることで、より限定的で精度の高いコンテキストを提供可能。

---

### チームナレッジのルール化＆ドキュメント化

-   **目的**: チームの開発ルールとドキュメントを適切に管理し、AIのコンテキストとして活用することで、一貫性のある開発を促進。
-   **メリット**:
    -   チーム内ルールの遵守を自然に促進。レビューの手間削減。
    -   新規メンバーのオンボーディング時に、関連ドキュメントを探す手間を省き、AI がガイド役になる。
    -   ドキュメントに基づいた正確なコード生成や修正が可能に。
-   **管理方針**:
    -   **外部サービス**: API仕様書など、外部サービスの最新仕様は`@Docs`で管理
    -   **内部ルール**: コーディング規約、設計標準、インフラ構成など、チーム固有のルールは`.cursor/rules`で管理
-   **追加方法**:
    -   **外部サービス**: チャットで`@Docs`と入力し、Add new docを選択。ローカルのファイルやフォルダ、またはアクセス可能なURLを指定
    -   **内部ルール**: `.cursor/rules`ファイルに直接記述
-   **アクション**: チームで共有すべき重要ドキュメントとルールを分類し、適切な場所に追加するプロセスを確立。

---

### 個人用Notepadの活用

-   **目的**: 個人の開発作業で頻繁に使用するプロンプトや、特定のタスクに関する指示をファイルに保存しておくことで、同じ文脈を繰り返し使い回せるようにする。
-   **方法**: Cursorの設定からNotepadオプションを有効にした後、@などから参照可能になる
-   **Tips**: 個人の作業効率を上げるために、よく使うプロンプトのテンプレートや、特定のタスクに関するメモをまとめておくと便利。必要に応じて更新・整理することで、より効率的な開発が可能に。

---

## 4. Cursorにおけるワークフローの効率化 (15 分)

---

### エージェント駆動開発 ("Vibe Coding")を試してみる

-   **コンセプト**: 開発者が大まかな指示や方向性を示し、AI (Agent) が具体的な実装の大部分を担当。人間はレビューや軌道修正を行うガイド役に徹する、新しい開発スタイル。
-   **可能性**: アイデアの高速プロトタイピング、API クライアント生成などの定型的な機能実装において、大幅な時間短縮が期待可能。
-   **注意点**:
    -   **コード品質のばらつき**: AI が常に最適で安全なコードを生成するとは限らない。冗長、非効率、脆弱なコードが含まれる可能性を認識する必要あり。
    -   **理解不足のリスク**: AI が生成したコードの動作原理を十分に理解しないまま進めると、デバッグ困難な問題や予期せぬ副作用を生むリスクあり。ブラックボックス化に注意。
    -   **過信禁物、レビュー必須**: 生成されたコードは必ず人間がレビューし、テストを行う責任あり。
-   **Tips**: まずは影響範囲の小さい機能や、明確に仕様が定義されたタスクから試してみること。AI の提案を鵜呑みにせず、常に批判的な視点を持つことが重要。

---

### 開発プロセスにおけるCursorの活用
#### エラー分析とデバッグ

- **エラー分析**
  - コンソールに出力されたエラーメッセージやスタックトレースをコピー
  - チャットに貼り付け、Cmd/Ctrl+K で「原因は何？」「どう修正すればいい？」と質問
  - 迅速な原因究明と修正案の提示が可能

- **ログを活用した反復修正**
  1. バグが潜んでいそうな箇所に詳細なログ出力（変数内容、処理フローなど）を追加
  2. プログラムを実行し、関連するログを取得
  3. 取得したログ情報をコンテキストとして AI に渡し、「このログから考えられる問題点は？」「修正案を提示して」と依頼
  4. 提案された修正を適用 → 再実行 → ログ確認、というサイクルを回し、効率的にデバッグを進行

#### テストとレビューとコミット

- **テスト生成/改善**
  - 対象のファイルや関数を指定し、「この関数のユニットテストを Jest で生成して」のように依頼
  - 既存のテストコードを提示し、「カバレッジを向上させるテストケースを追加して」「このエッジケースをテストするコードを書いて」のように、テストの質的改善を依頼

- **レビュー依頼**
  - 人にレビューを依頼する前にローカルでレビューを実施
  - `git diff --staged | clip` でコピーしてコンテキストをチャットに渡してレビューを依頼
  - @gitシンボルだと差分を拾いきれない場合も...

- **コミット**
  - コミットメッセージの自動生成が可能
  - 基本的にはこれまでのコミットメッセージを参考にしてくれるが裏技としてcursorrulesでレビューフォマットを指定できる

> **Tips**: テストでもレビューでもルールをコンテキストに入れておくとより精度の高い回答が得られます

#### 自動化モード

- **Auto Applayモード**
  - AI によるファイル変更提案を自動で適用するモード
  - デバッグサイクルは高速化するが、意図しない変更が適用されることがある
  - ステージングと組み合わせると良い

- **Auto Runモード**
  - Agentが実行するコマンドを自動承認するモード
  - 意図しないコマンドが実行される危険性がある
  - 慣れるまではオフにしておくことを推奨

---

### 効果的なプロンプトエンジニアリング

-   **良いプロンプトの要素**:
    -   **明確性**: 達成したいことを具体的に、曖昧さを排除して記述。「いい感じにして」ではなく「この関数のパフォーマンスを改善して」。
    -   **具体性**: 対象コード、期待する出力形式（例: JSON 形式で）、制約条件（例: Python 3.8 互換で）などを明確に指定。
    -   **背景情報**: なぜその変更が必要か、どのような文脈で使われるか、関連する他の要素は何か、といった背景を伝達 (@シンボル活用)。
    -   **役割付与**: 「あなたは熟練の React エンジニア。このコンポーネントをレビューせよ」のように役割を与えることで、専門的な視点からの回答を引き出す。
-   **試してみる価値のあるテクニック**:
    -   **音声入力**: 、タイピングより思考に近いスピードで指示を出せる可能性。
    -   **AI への逆質問**: AI の回答が曖昧な場合、「〇〇について、もっと情報が必要か？」「△△ という理解で合っているか？」のように問いかけ、対話を通じて精度を向上。

---



## 5. チームでの Cursor 活用を最適化する：カスタマイズと標準化 (10 分)

---

### プロジェクトルールの設計

-   **目的**: プロジェクトごとに AI の振る舞いやコーディングスタイルに関するルールを定義することで、チームメンバー間のアウトプットのばらつきを抑え、一貫性のある開発を促進。レビューの効率化にも直結。
-   **場所**: プロジェクトルートに .cursorrules ファイル (または .cursor/rules.md) を作成。このファイルはリポジトリにコミットし、チームで共有。
-   **内容例**:
    -   **プロジェクト固有指示**: 「この API は RESTful 原則に従うこと」
    -   **コーディング規約**: 「TypeScript の型は厳密に定義すること」「コメントは JSDoc 形式で」
    -   **技術スタック指定**: 「状態管理には Zustand を使用する」
    -   **AI 振る舞いガイド**: 「コード生成時は必ずエラーハンドリングを含めること」「セキュリティ脆弱性を生まないよう注意すること」
    -   **MCP 利用ルール**: 「DB への書き込み操作は禁止」
-   **効果**: 新メンバーもすぐにプロジェクト標準に沿った形で AI を活用でき、コードの品質と一貫性が自然に維持。
-   **アクション**: 主要なプロジェクト向けに、チームのコーディング規約や技術方針を反映した共通のテンプレートを作成し、導入を検討。

---

### グローバルルールとモデル選択

-   **個人設定 (Global Rules)**: Settings > Features > Rules for AI で、すべてのプロジェクトに共通で適用したい個人的な指示を設定可能。「常に応答は日本語で」「変数名は具体的に」など、個人の効率を高めるルールを登録。
-   **モデル選択**: Settings > Models で利用する LLM を選択。
    -   **Auto-select**: Cursor がタスク内容に応じて速度重視モデルと高性能モデルを自動で切り替え。通常はこれがバランスが良く推奨。
    -   **特定モデル指定**: GPT-4o, Claude 3 Opus などを明示的に指定。特定の複雑なタスクで高い性能を発揮する場合あり。ただし、応答速度が遅くなったり、コストが増えたりする可能性あり。
    -   **Large Context Mode**: より多くのコンテキスト（ファイル数、トークン数）を扱えるが、これも応答速度低下とコスト増に直結。本当に広範囲の参照が必要な場合に限定して有効化するのが賢明。

---

## 6. Cursor を拡張する：MCP と外部ツール連携の実践 (15 分)

---

### MCP (Model Context Protocol) とは？ その価値は？

-   **概要**: Cursor の Agent が、IDE の「外」にあるツールやデータソース（Jira, GitHub API, 社内 DB, カスタムスクリプト等）と対話できるようにする仕組み。
-   **目的・価値**: これまで IDE とブラウザ/別ツール間で行っていたコンテキストスイッチ（画面切り替え、コピペ等）を大幅に削減し、開発ワークフローを可能な限り IDE 内で完結させることを目指す。
-   **仕組み**: Agent がタスクを解釈し、適切な MCP サーバー（外部ツールとの橋渡し役）を呼び出し、対話。

---

### MCP のチームへの有用性：具体的な連携例

---

#### ツール連携:

-   **Jira/GitHub**: IDE 内でチケット内容確認 、ステータス更新、PR コメント追加など。ブラウザを開く手間を削減。
-   **Slack**: ビルド完了通知を送信 、関連する過去の議論を検索してコンテキストに追加など。
-   **Figma**: コンポーネントのデザインスペック（マージン、色など）を参照 しながらコーディング。

---

#### 情報アクセス:

-   **DB**: テーブルスキーマを確認 、テストデータの投入状況を確認する簡単なクエリ実行 。
-   **社内文書検索**: @Docs に登録していない Confluence 等の情報を検索 。
-   **高度な Web 検索**: 特定技術の最新情報やベストプラクティスを検索 。

---

#### 自動化/支援:

-   **ブラウザ操作 (Puppeteer 等)**: E2E テスト実行の補助や、特定の Web 操作の自動化 。
-   **Git 操作補助**: 複雑なブランチ戦略やコマンド実行を支援 。

---

### 実践的な MCP サーバー例と導入手順

-   **サーバー例**: 公式・コミュニティから多様なサーバーが提供 (GitHub/Jira, Slack, 各種 DB, Filesystem, Browsertools, Figma, Google Search 等)。
-   **探し方**: Cursor 公式ドキュメントの MCP セクション、GitHub で cursor-mcp 等のキーワード検索、非公式リストサイト (cursor.directory 等) を参照。チーム固有ツール連携のために自作することも可能。
-   **導入手順**:
    1. **有効化**: Settings > Features > Model Controller Plugin (MCP) をオンにする。
    2. **サーバー設定**: 設定ファイル (.cursor/mcp.json (プロジェクト共有) or ~/.cursor/mcp.json (個人用)) に、使用する MCP サーバーの情報を記述。内容はサーバーの種類によるが、主に通信方式 (stdio, sse)、起動コマンド/URL、認証情報（API キー等、環境変数推奨）を指定。
    3. **利用開始**: 公式/コミュニティ提供サーバーの場合は、通常 README 等に設定例が記載。自作の場合は、Cursor の指定するプロトコルに従ってサーバーを実装。

---

### MCP の使い方と注意点：可能性とリスク

-   **使い方**: Agent モード (Cmd/Ctrl+L -> Agent) で、「検索して」「この PR をレビューして」「このチケットを解決済にして」のように、連携したいURLや特定の用語を含めてタスクを指示。Cursor が適切な MCP を提案・実行。
-   **注意点**:
    -   **発展途上の技術**: MCP は比較的新しく、今後仕様変更や改善が進む可能性あり。
    -   **サーバー品質**: 提供される MCP サーバーの品質や安定性は様々。期待通りに動作しない、不安定になる可能性も考慮が必要。
    -   **設定**: 環境によっては設定が複雑だったり、試行錯誤が必要だったりする場合あり。
    -   **セキュリティ**: 外部サービス連携には API キー等の認証情報が関与。トークン管理は慎重に行い、.env ファイルや環境変数での管理を徹底すること。
-   **推奨**: まずは広く使われており、比較的安定していると思われるサーバー（GitHub 連携、ローカルファイル操作など）から導入し、その価値と安定性を評価するのが良い。

---


## 7. 注意点とベストプラクティス (10 分)

---

### 「検証」は必須

-   AI は万能ではない。生成されたコードが常に正しいとは限らず、バグ、非効率、脆弱性を含む可能性あり。
-   コードレビューとテストによる検証プロセスは、AI 利用時こそ重要。
-   生成されたコードの動作原理を理解する努力も必要。

---


### スキル低下懸念

-   AI に頼りすぎることで、基礎的なプログラミング能力やデバッグ能力、設計能力が低下するリスク。
-   AI はあくまで開発者の能力を「増幅」するツール。基礎がなければ効果は限定的。
-   AI の提案に対して「なぜ？」と考える能動的な学習姿勢を保つこと。

---

### バージョン管理徹底

-   AI は時に広範囲な変更を提案・実行。
-   意図しない変更が含まれる可能性も考慮し、作業前後のこまめなコミットステージングを徹底。
-   問題発生時に容易に元に戻せる状態を維持することが、AI 活用時の安全網。

---


## 8. まとめと Q&A (10 分)

---

### まとめ

1. コア機能（Tab, K, L）の応用的な使い方をマスターする。
2. AI の精度は「コンテキスト」が命。@シンボル, @Docs, Rulesなど を使いこなす。
3. コーディングルールの標準化,ドキュメント化を進める。
4. 高度なワークフロー（Agent 駆動開発, AI デバッグ/テスト, プロンプト術）を取り入れる。
5. MCP による外部ツール連携で、IDE 中心の開発フローを実現する。
6. 常に注意点を意識し、検証を怠らない健全な活用を心がける。
---

### Q&A

疑問点や気になることがあれば、遠慮なく質問してください。
